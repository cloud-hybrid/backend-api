#!/usr/bin/env bash

# -*-  Coding: UTF-8  -*- #
# -*-  System: Linux  -*- #
# -*-  Usage:   *.*   -*- #

# ========================================================================
# --> SSH Management
# ========================================================================

# To encrypt a target using RSA algorithm, the modulus (n)
# and public encryption source (e) exponent pair (n, e) is needed;
# such is public key. To decrypt a source using RSA algorithm
# the modulus (n) and private decryption source (d) exponent
# pair (n, d); such is the private key.
#
# To encrypt a target using RSA public key, treat the source's
# **plaintext (source) as a number and raise it to the power of
# (^)(e) modulus (%) (n):
#
# >>> $ ciphertext = ( source^e ) mod n
#
# In terms of RSA encryption keys, decryption of a private key
# is done via using the **ciphertext (source) as a number and
# raising it to the power (^)(d) modulus (%)(n):
#
# >>> $ plaintext = ( source^d ) mod n
#
# To generate private (d, n) key using openssl:
#
# >>> $ openssl genrsa -out private.pem 1024
#
# To generate public (e, n) key from the private key using openssl:
#
# >>> $ openssl rsa -in private.pem -out public.pem -pubout
#
# To dissect the contents of the private.pem private RSA key
# generated by the openssl command above:
#
# openssl rsa -in private.pem -text -noout | less
#
# modulus         - n
# privateExponent - d
# publicExponent  - e
# prime1          - p
# prime2          - q
# exponent1       - d mod (p-1)
# exponent2       - d mod (q-1)
# coefficient     - (q^-1) mod p
#
# Shouldn't private key consist of (n, d) pair only? Why are there 6
# extra components? It contains e (public exponent) so that public
# RSA key can be generated/extracted/derived from the private.pem
# private RSA key. The rest 5 components are there to speed up the
# decryption process. It turns out that by pre-computing and storing
# those 5 values it is possible to speed the RSA decryption by the
# factor of 4. Decryption will work without those 5 components, but it
# can be done faster if you have them handy. The speeding up algorithm
# is based on the Chinese Remainder:
#
# - https://en.wikipedia.org/wiki/RSA_(cryptosystem)
#
# The private.pem RSA private key actually contains all of those 8 values;
# none of them are generated on the fly when running the previous command.
#
# >>> $ # Convert the key from PEM to DER (binary) format
# >>> $ openssl rsa -in private.pem -outform der -out private.der
#
# # Print private.der private key contents as binary stream
# xxd -p private.der
#
# >>> $ # Now compare the output of the above command with output
# >>> $ # of the earlier openssl command that outputs private key
# >>> $ # components. If you stare at both outputs long enough
# >>> $ # you should be able to confirm that all components are
# >>> $ # indeed lurking somewhere in the binary stream
#
# openssl rsa -in private.pem -text -noout | less
#
# Such structure of the RSA private key is recommended by the PKCS#1
# v1.5 as an alternative (second) representation. PKCS#1 v2.0 standard
# excludes (e) and (d) exponents from the alternative representation
# altogether. PKCS#1 v2.1 and v2.2 propose further changes to the alternative
# representation by optionally including more CRT-related components.
#
# To see the contents of the public.pem public RSA key run
# the following (output truncated to labels here):
#
# >>> $ openssl rsa -in public.pem -text -pubin -noout
# ...
# ... Modulus             - n
# ... Exponent (public)   - e
# ...
#
# STDOUT'ed the (n, e) pair, as promised.
#
# As was shown above, private RSA key generated using openssl contains components
# of both public and private keys and some more. When you generate/extract/derive
# public key from the private key, openssl copies two of those components (e,n)
# into a separate file which becomes the target, public key.
#
# In quick summary:
#
# To generate a private key (RSA):
#
# >>> $ openssl genrsa -out private|.pem|.rsa|.key|... 4096
#
# To generate the public key from the private key (RSA):
#
# >>> $ openssl rsa -in private.pem -out public|.pem|.rsa|.key|... -pubout
#

if [ ! -n "${1}" ]; then echo "Input ['private'|'public'] Required" && exit -1; fi

# ========================================================================
# --> Generate (Private | Public) Key (*.PEM)
# ========================================================================

if [[ "${1}" == "private" ]]; then
    if [ ! -n "${2}" ]; then
        openssl genrsa -out "PEM-Private-Key.pem" 4096
    else
        openssl genrsa -out "${2}" 4096
    fi
else
    if [[ "${1}" == "public" ]]; then
        if [ ! -n ${2} ]; then echo "Private Key Required" && exit -1; fi
        _key="$(echo ${2} | sed -E 's/\.(pem|rsa|pub|dem|pks|private|der|.)//g')-Public.pem"
        openssl rsa -in "${2}" -out "${_key}" -pubout
        chmod 400 ${2} && chmod 644 ${_key}
    else echo "Unknown Input" && exit -1
    fi
fi
