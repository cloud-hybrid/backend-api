

## Artifacts & Caching ##

Don’t use caching for passing artifacts between stages, as it is designed to store runtime dependencies needed to 
compile the project:

  - `cache`: **Storing Project Dependencies**
    
    Caches are used to speed up runs of a given job in subsequent pipelines, by storing downloaded dependencies so that
    they don’t have to be fetched from the internet again (like npm packages, Go vendor packages, etc.) While the cache
    could be configured to pass intermediate build results between stages, this should be done with artifacts instead.
    
  - `artifacts`: **Passing Stage Results Between Jobs**
  
    Artifacts are files generated by a job which are stored and uploaded, and can then be fetched and used by jobs in 
    later stages of the same pipeline. In other words, you can’t create an artifact in job-A in stage-1, and then use 
    this artifact in job-B in stage-1. This data will not be available in different pipelines, but is available to be 
    downloaded from the UI.

The name `artifacts` sounds like it’s only useful outside of the job, like for downloading a final image, but artifacts 
are also available in later stages within a pipeline. So if you build your application by downloading all the required 
modules, you might want to declare them as artifacts so that subsequent stages can use them. There are some 
optimizations like declaring an expiry time so you don’t keep artifacts around too long, or using dependencies to 
control which jobs fetch the artifacts.

### Caches ###

- Are disabled if not defined globally or per job (using `cache:`).
- Are available for all jobs in your .gitlab-ci.yml if enabled globally.
- Can be used in subsequent pipelines by the same job in which the cache was created (if not defined globally).
- Are stored where GitLab Runner is installed and uploaded to S3 if distributed cache is enabled.
- If defined per job, are used:
    - By the same job in a subsequent pipeline.
    - By subsequent jobs in the same pipeline, if they have identical dependencies.

#### Python Example ####

```yaml
#
# https://gitlab.com/gitlab-org/gitlab/tree/master/lib/gitlab/ci/templates/Python.gitlab-ci.yml
#

image: python:latest

# Change pip's cache directory to be inside the project directory since we can
# only cache local items.

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

# Pip's cache doesn't store the python packages
# https://pip.pypa.io/en/stable/reference/pip_install/#caching
#
# If you want to also cache the installed packages, you have to install
# them in a virtualenv and cache it as well.

cache:
  paths:
    - .cache/pip
    - venv/

before_script:
  - python -V
  - pip install virtualenv
  - virtualenv venv
  - source venv/bin/activate

test:
  script:
    - python setup.py test
    - pip install flake8
    - flake8 .
```

#### Go Example ####

Commonly [Go-Modules](https://github.com/golang/go/wiki/Modules) is used when installing dependencies; the following
snippet employs a cache for a `GO`-specific project that later can be extended via any job. Go modules are installed 
in ${GOPATH}/pkg/mod/ and are cached for all of the go projects:

```yaml
.go-cache:
  variables:
    GOPATH: $CI_PROJECT_DIR/.go
  before_script:
    - mkdir -p .go
  cache:
    paths:
      - .go/pkg/mod/

test:
  image: golang:1.13
  extends: .go-cache
  script:
    - go test ./... -v -short
```

### Artifacts ###

- Are disabled if not defined per job (using `artifacts:`).
- Can only be enabled per job, not globally.
- Are created during a pipeline and can be used by the subsequent jobs of that currently active pipeline.
- Are always uploaded to GitLab (known as coordinator).
- Can have an expiration value for controlling disk usage (30 days by default).

### Cache Availability ### 

Caching is an optimization, but isn't guaranteed to always work.

Assuming a properly [defined `cache` in `.gitlab-ci.yml`](https://gitlab.com/gitlab-org/gitlab/blob/master/doc/ci/README.md#cache)
according to a workflow, the availability of the cache ultimately depends on
how the runner has been configured (the executor type and whether different
runners are used for passing the cache between jobs).

### Cache Storage ###

Since the runner is the one responsible for storing the cache, it's essential
to know **where** it's stored. All the cache paths defined under a job in
`.gitlab-ci.yml` are archived in a single `cache.zip` file and stored in the
runner's configured cache location. By default, they are stored locally in the
machine where the runner is installed and depends on the type of the executor.

| GitLab Runner executor | Default path of the cache |
| ---------------------- | ------------------------- |
| [Shell](https://docs.gitlab.com/runner/executors/shell.html) | Locally, stored under the `gitlab-runner` user's home directory: `/home/gitlab-runner/cache/<user>/<project>/<cache-key>/cache.zip`. |
| [Docker](https://docs.gitlab.com/runner/executors/docker.html) | Locally, stored under [Docker volumes](https://docs.gitlab.com/runner/executors/docker.html#the-builds-and-cache-storage): `/var/lib/docker/volumes/<volume-id>/_data/<user>/<project>/<cache-key>/cache.zip`. |
| [Docker machine](https://docs.gitlab.com/runner/executors/docker_machine.html) (autoscale runners) | Behaves the same as the Docker executor. |

